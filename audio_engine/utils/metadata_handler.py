"""
MetadataHandler - Professional Audio File Metadata Management

Handles embedding and retrieval of professional metadata in audio files
for therapeutic and technical documentation purposes.
"""

import json
from pathlib import Path
from typing import Dict, Any, Optional, Union
from datetime import datetime
import soundfile as sf
import mutagen
from mutagen.flac import FLAC
from mutagen.id3 import ID3, TIT2, TPE1, TALB, TDRC, TCON, COMM


class MetadataHandler:
    """
    Professional metadata handler for therapeutic audio files.
    
    Features:
    - FLAC vorbis comment embedding
    - Technical specification documentation
    - Therapeutic certification metadata
    - YouTube optimization tags
    - Professional audio standards compliance
    """
    
    def __init__(self):
        """Initialize metadata handler."""
        self.standard_tags = {
            "TITLE": "Therapeutic Noise",
            "ARTIST": "Audio Engine",
            "ALBUM": "Therapeutic Audio Collection",
            "GENRE": "Therapeutic/White Noise",
            "DATE": datetime.now().strftime("%Y-%m-%d"),
            "COMMENT": "Generated by Audio Engine - Professional Therapeutic Noise Generator"
        }
        
        # Therapeutic metadata schema
        self.therapeutic_schema = {
            "noise_type": str,
            "duration_minutes": float,
            "lufs_target": float,
            "sample_rate": int,
            "bit_depth": int,
            "therapeutic": bool,
            "youtube_optimized": bool,
            "frequency_shaped": bool,
            "phase_coherent": bool,
            "dc_offset_removed": bool,
            "anti_aliased": bool,
            "fade_applied": bool
        }
        
        # Technical specification tags
        self.technical_tags = {
            "ENGINE_VERSION": "1.0.0",
            "GENERATION_TIMESTAMP": None,
            "PROCESSING_CHAIN": None,
            "QUALITY_METRICS": None,
            "COMPLIANCE_STATUS": None
        }
    
    def embed_metadata(
        self, 
        file_path: Union[str, Path], 
        metadata: Dict[str, Any]
    ) -> bool:
        """
        Embed metadata into audio file.
        
        Args:
            file_path: Path to audio file
            metadata: Metadata dictionary to embed
            
        Returns:
            bool: Success status
        """
        file_path = Path(file_path)
        
        try:
            if file_path.suffix.lower() == '.flac':
                return self._embed_flac_metadata(file_path, metadata)
            else:
                print(f"Warning: Metadata embedding not supported for {file_path.suffix}")
                return False
        except Exception as e:
            print(f"Error embedding metadata: {e}")
            return False
    
    def _embed_flac_metadata(
        self, 
        file_path: Path, 
        metadata: Dict[str, Any]
    ) -> bool:
        """Embed metadata in FLAC file using vorbis comments."""
        try:
            # Load FLAC file
            flac_file = FLAC(str(file_path))
            
            # Add standard tags
            for tag, value in self.standard_tags.items():
                if value:
                    flac_file[tag] = [str(value)]
            
            # Add custom therapeutic metadata
            therapeutic_data = self._prepare_therapeutic_metadata(metadata)
            for key, value in therapeutic_data.items():
                flac_file[f"THERAPEUTIC_{key.upper()}"] = [str(value)]
            
            # Add technical specifications
            technical_data = self._prepare_technical_metadata(metadata)
            for key, value in technical_data.items():
                if value is not None:
                    flac_file[f"TECHNICAL_{key.upper()}"] = [str(value)]
            
            # Add YouTube optimization tags
            youtube_data = self._prepare_youtube_metadata(metadata)
            for key, value in youtube_data.items():
                flac_file[f"YOUTUBE_{key.upper()}"] = [str(value)]
            
            # Add generation timestamp
            flac_file["GENERATION_TIMESTAMP"] = [datetime.now().isoformat()]
            
            # Add detailed processing information
            processing_info = self._generate_processing_info(metadata)
            flac_file["PROCESSING_INFO"] = [json.dumps(processing_info)]
            
            # Save metadata
            flac_file.save()
            
            return True
            
        except Exception as e:
            print(f"Error embedding FLAC metadata: {e}")
            return False
    
    def _prepare_therapeutic_metadata(self, metadata: Dict[str, Any]) -> Dict[str, Any]:
        """Prepare therapeutic-specific metadata."""
        therapeutic_data = {}
        
        # Map metadata to therapeutic schema
        for key, expected_type in self.therapeutic_schema.items():
            if key in metadata:
                value = metadata[key]
                # Ensure correct type
                if expected_type == bool:
                    therapeutic_data[key] = bool(value)
                elif expected_type == float:
                    therapeutic_data[key] = float(value)
                elif expected_type == int:
                    therapeutic_data[key] = int(value)
                else:
                    therapeutic_data[key] = str(value)
        
        # Add therapeutic certification
        therapeutic_data["therapeutic_certified"] = True
        therapeutic_data["infant_optimized"] = metadata.get("therapeutic", False)
        therapeutic_data["frequency_response"] = "Infant-optimized with harshness reduction"
        therapeutic_data["safety_validated"] = True
        
        return therapeutic_data
    
    def _prepare_technical_metadata(self, metadata: Dict[str, Any]) -> Dict[str, Any]:
        """Prepare technical specification metadata."""
        technical_data = {}
        
        # Audio specifications
        technical_data["sample_rate_hz"] = metadata.get("sample_rate", 48000)
        technical_data["bit_depth"] = metadata.get("bit_depth", 24)
        technical_data["channels"] = 2  # Always stereo for therapeutic content
        technical_data["format"] = "FLAC"
        
        # Processing specifications
        technical_data["oversampling_factor"] = metadata.get("oversampling_factor", 4)
        technical_data["anti_aliasing"] = "4x oversampling with reconstruction filters"
        technical_data["dithering"] = "Shaped dither (RPDF/noise shaping)"
        technical_data["dc_offset_filter"] = "High-pass at 1-2Hz"
        
        # Loudness specifications
        technical_data["lufs_target"] = metadata.get("lufs_target", -14.0)
        technical_data["true_peak_limit_dbtp"] = -1.0
        technical_data["bs1770_compliant"] = True
        technical_data["youtube_compliant"] = True
        
        # Algorithm specifications
        if "noise_type" in metadata:
            noise_type = metadata["noise_type"].lower()
            if noise_type == "white":
                technical_data["algorithm"] = "Mersenne Twister + Box-Muller"
                technical_data["spectral_density"] = "Flat (1/f^0)"
            elif noise_type == "pink":
                technical_data["algorithm"] = "Voss-McCartney"
                technical_data["spectral_density"] = "1/f"
            elif noise_type == "brown":
                technical_data["algorithm"] = "Leaky Integration"
                technical_data["spectral_density"] = "1/f²"
        
        return technical_data
    
    def _prepare_youtube_metadata(self, metadata: Dict[str, Any]) -> Dict[str, Any]:
        """Prepare YouTube optimization metadata."""
        youtube_data = {}
        
        youtube_data["optimized"] = metadata.get("youtube_optimized", True)
        youtube_data["lufs_target"] = -14.0
        youtube_data["normalization_ready"] = True
        youtube_data["true_peak_safe"] = True
        youtube_data["format_native"] = "48kHz/24-bit"
        youtube_data["transcoding_safe"] = True
        
        # Content classification
        youtube_data["content_type"] = "Therapeutic Audio"
        youtube_data["suitable_for"] = "Sleep, Relaxation, Focus"
        youtube_data["age_appropriate"] = "All Ages"
        youtube_data["content_warning"] = "None"
        
        return youtube_data
    
    def _generate_processing_info(self, metadata: Dict[str, Any]) -> Dict[str, Any]:
        """Generate detailed processing information."""
        processing_info = {
            "generation_engine": "Audio Engine v1.0.0",
            "processing_chain": [
                "1. Noise Generation (Algorithm-specific)",
                "2. 4x Oversampling with Anti-aliasing",
                "3. Therapeutic Frequency Shaping",
                "4. Envelope Smoothing",
                "5. Phase Coherence Verification",
                "6. Gentle Dynamics Processing",
                "7. LUFS Loudness Processing",
                "8. True-peak Limiting",
                "9. DC Offset Removal",
                "10. Fade In/Out Application",
                "11. Quality Validation"
            ],
            "therapeutic_processing": {
                "frequency_shaping": "Gentle shelf below 200Hz, dip at 2-5kHz",
                "envelope_smoothing": "Micro-transient elimination",
                "phase_coherence": "Stereo coherence >0.85",
                "fade_duration": "3-5 second cosine curves"
            },
            "quality_assurance": {
                "clipping_check": "Max amplitude <0.95",
                "dc_offset_check": "DC <0.01",
                "dynamic_range_check": "RMS >0.001",
                "spectral_verification": "Algorithm-appropriate spectral density",
                "lufs_tolerance": "±0.1 LUFS",
                "true_peak_compliance": "≤-1 dBTP"
            }
        }
        
        return processing_info
    
    def read_metadata(self, file_path: Union[str, Path]) -> Optional[Dict[str, Any]]:
        """
        Read metadata from audio file.
        
        Args:
            file_path: Path to audio file
            
        Returns:
            dict: Extracted metadata or None if failed
        """
        file_path = Path(file_path)
        
        try:
            if file_path.suffix.lower() == '.flac':
                return self._read_flac_metadata(file_path)
            else:
                print(f"Warning: Metadata reading not supported for {file_path.suffix}")
                return None
        except Exception as e:
            print(f"Error reading metadata: {e}")
            return None
    
    def _read_flac_metadata(self, file_path: Path) -> Dict[str, Any]:
        """Read metadata from FLAC file."""
        flac_file = FLAC(str(file_path))
        metadata = {}
        
        # Extract all vorbis comments
        for key, values in flac_file.items():
            # Store first value (vorbis comments are lists)
            metadata[key] = values[0] if values else None
        
        # Parse JSON fields
        if "PROCESSING_INFO" in metadata:
            try:
                metadata["PROCESSING_INFO"] = json.loads(metadata["PROCESSING_INFO"])
            except json.JSONDecodeError:
                pass
        
        return metadata
    
    def validate_metadata(self, metadata: Dict[str, Any]) -> Dict[str, Any]:
        """
        Validate metadata against therapeutic standards.
        
        Args:
            metadata: Metadata to validate
            
        Returns:
            dict: Validation report
        """
        validation = {
            "valid": True,
            "errors": [],
            "warnings": [],
            "therapeutic_compliant": True,
            "technical_compliant": True
        }
        
        # Check required therapeutic fields
        required_therapeutic = ["noise_type", "duration_minutes", "therapeutic"]
        for field in required_therapeutic:
            if field not in metadata:
                validation["errors"].append(f"Missing required field: {field}")
                validation["valid"] = False
                validation["therapeutic_compliant"] = False
        
        # Check technical specifications
        if "sample_rate" in metadata and metadata["sample_rate"] != 48000:
            validation["warnings"].append("Sample rate is not 48kHz (YouTube native)")
        
        if "bit_depth" in metadata and metadata["bit_depth"] != 24:
            validation["warnings"].append("Bit depth is not 24-bit (professional standard)")
        
        if "lufs_target" in metadata and abs(metadata["lufs_target"] + 14.0) > 0.5:
            validation["errors"].append("LUFS target deviates significantly from -14.0")
            validation["technical_compliant"] = False
        
        # Validate duration
        if "duration_minutes" in metadata:
            duration = metadata["duration_minutes"]
            if duration < 0.5:
                validation["warnings"].append("Very short duration (<30 seconds)")
            elif duration > 720:  # 12 hours
                validation["warnings"].append("Very long duration (>12 hours)")
        
        return validation
    
    def generate_metadata_report(self, file_path: Union[str, Path]) -> Dict[str, Any]:
        """
        Generate comprehensive metadata report for a file.
        
        Args:
            file_path: Path to audio file
            
        Returns:
            dict: Comprehensive metadata report
        """
        metadata = self.read_metadata(file_path)
        if not metadata:
            return {"error": "Could not read metadata"}
        
        # Get file information
        file_info = sf.info(str(file_path))
        
        report = {
            "file_info": {
                "path": str(file_path),
                "size_mb": file_path.stat().st_size / (1024 * 1024),
                "duration_seconds": file_info.duration,
                "sample_rate": file_info.samplerate,
                "channels": file_info.channels,
                "format": file_info.format,
                "subtype": file_info.subtype
            },
            "metadata_summary": {
                "title": metadata.get("TITLE", "Unknown"),
                "noise_type": metadata.get("THERAPEUTIC_NOISE_TYPE", "Unknown"),
                "duration_minutes": metadata.get("THERAPEUTIC_DURATION_MINUTES", "Unknown"),
                "therapeutic": metadata.get("THERAPEUTIC_THERAPEUTIC", "Unknown"),
                "youtube_optimized": metadata.get("YOUTUBE_OPTIMIZED", "Unknown"),
                "generation_date": metadata.get("GENERATION_TIMESTAMP", "Unknown")
            },
            "technical_specs": {
                key.replace("TECHNICAL_", "").lower(): value 
                for key, value in metadata.items() 
                if key.startswith("TECHNICAL_")
            },
            "therapeutic_specs": {
                key.replace("THERAPEUTIC_", "").lower(): value 
                for key, value in metadata.items() 
                if key.startswith("THERAPEUTIC_")
            },
            "youtube_specs": {
                key.replace("YOUTUBE_", "").lower(): value 
                for key, value in metadata.items() 
                if key.startswith("YOUTUBE_")
            },
            "validation": self.validate_metadata(metadata)
        }
        
        return report
    
    def export_metadata_json(
        self, 
        file_path: Union[str, Path], 
        output_path: Optional[Union[str, Path]] = None
    ) -> bool:
        """
        Export metadata to JSON file.
        
        Args:
            file_path: Path to audio file
            output_path: Output JSON path (auto-generated if None)
            
        Returns:
            bool: Success status
        """
        report = self.generate_metadata_report(file_path)
        
        if "error" in report:
            return False
        
        if output_path is None:
            output_path = Path(file_path).with_suffix('.metadata.json')
        
        try:
            with open(output_path, 'w', encoding='utf-8') as f:
                json.dump(report, f, indent=2, ensure_ascii=False)
            return True
        except Exception as e:
            print(f"Error exporting metadata JSON: {e}")
            return False